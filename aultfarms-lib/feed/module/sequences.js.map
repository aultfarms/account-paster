{"version":3,"sources":["../../src/feed/module/sequences.js"],"names":["processCards","store","get","cards","state","console","log","records","_","map","c","name","error","card","matches","match","date","trim","rest","sourceAndNumber","replace","source","toUpperCase","loadNumber","weight","destination","driver","note","invoiced","find","labels","l","color","paidFor","truckingPaid","set","sortBy","d","ignoreBefore","recentDeliveries","filter","isBefore","notInvoiced","groupBy","n","notPaidFor","p","truckingNotPaid","t","fetch","boardName","listName","key","loadList"],"mappings":"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","file":"sequences.js","sourcesContent":["import _ from 'lodash';\nimport moment from 'moment';\nimport { set } from 'cerebral/factories';\nimport { state, sequence } from 'cerebral';\n\nimport { loadList } from '../../trello/module/sequences';\n\n\n// Example cards:\n// 2017-01-26: Df pellets 1-26-17 209366.  48.620 lbs - Home - Brock\n// 2017-01-24: North Central Pallets46470.  8 lbs - Home - Andrew.  Note: some info\nfunction processCards({store,get}) {\n  // First parse the cards, then later determine invoiced list, non-invoiced list, etc.\n  const cards = get(state`trello.lists.feedDeliveries.cards`);\nconsole.log('processCards: got cards = ', cards);\n  const records = _.map(cards, c => {\n    if (!c.name) { return { error: 'card name does not exist', card: c } }\n    // Date on front:\n    let matches = c.name.match(/([0-9]{4}-[0-9]{2}-[0-9]{2}): *(.*)$/);\n    const date = moment(matches[1].trim(), 'YYYY-MM-DD');\n    let rest = matches[2];\n    // Next is source+number (up to a period)\n    matches = rest.match(/^([^.]*). *(.*)$/);\n    rest = matches[2];\n    const sourceAndNumber = matches[1].trim().replace('/ *pellets */g','');\n\n    matches = sourceAndNumber.match(/^([^0-9]+)?(.*)$/);\n    const source = (matches[1] ? matches[1].trim() : 'NONE').toUpperCase();\n    const loadNumber = matches[2] ? matches[2].trim() : '';\n\n    // Then comes pounds w/ period instead of comma sometimes\n    matches = rest.match(/(([0-9]+[,.])?[0-9]*) +lbs +- +(.*)$/);\n    const weight = +(matches[1].replace(/[,.]/g,'').trim()); // convert to number\n    rest = matches[3];\n    // Then comes destination\n    matches = rest.match(/([^-]+) *- *(.*)$/);\n    const destination = matches[1].toUpperCase().trim();\n    rest = matches[2];\n    // Now driver\n    matches = rest.match(/([^.]*)(. *(.*))?$/);\n    const driver = matches[1].trim();\n    rest = matches[3] || '';\n    // Optional note\n    matches = rest.match(/Note: *(.*)$/);\n    const note = (matches && matches[1].trim()) || '';\n\n    // Set true/false properties based on labels:\n    const     invoiced = !!(_.find(c.labels, l => l.color === 'orange'));\n    const      paidFor = !!(_.find(c.labels, l => l.color === 'green'));\n    const truckingPaid = !!(_.find(c.labels, l => l.color === 'blue'));\n\n    return { date, source, loadNumber, weight, destination, driver, note, invoiced, paidFor, truckingPaid, card: c };\n  });\n  store.set(state`feed.records`, _.sortBy(records, d => d.date));\n\n  //---------------------------------------------------------\n  // Before grouping/filtering, eliminate cards older than we care about:\n  const ignoreBefore = moment(get(state`feed.ignoreBefore`), 'YYYY-MM-DD');\n  const recentDeliveries = _.filter(records, d => ignoreBefore.isBefore(d.date));\n\n  //----------------------------------------------------------\n  // Find loads not billed, group by destination\n  let notInvoiced = _.filter(recentDeliveries, d => !(d.invoiced));\n  notInvoiced = _.filter(notInvoiced, d => d.destination.toUpperCase() !== 'HOME');\n  store.set(state`feed.notInvoiced`, _.groupBy(notInvoiced, n => n.destination));\n\n  //---------------------------------------------------------\n  // Find loads not paid for by us, group by source:\n  let notPaidFor = _.filter(recentDeliveries, d => !(d.paidFor));\n  store.set(state`feed.notPaidFor`, _.groupBy(notPaidFor, p => p.source));\n\n  //----------------------------------------------------------------------------------\n  // Find loads that Brad hauled which we have not been billed for, group by source:\n  let truckingNotPaid = _.filter(recentDeliveries, d => d.driver.toUpperCase() === 'BRAD');\n  truckingNotPaid = _.filter(truckingNotPaid, d => !(d.truckingPaid));\n  store.set(state`feed.truckingNotPaid`, _.groupBy(truckingNotPaid, t => t.source));\n}\n\n\nexport const fetch = sequence('feed.fetch', [\n  () => ({ boardName: 'Feed', listName: 'Feed Delivered', key: 'feedDeliveries' }),\n  loadList,\n  processCards,\n  set(state`feed.ready`, true),\n]);\n\n\n"]}